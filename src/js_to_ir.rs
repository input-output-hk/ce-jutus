//! Visit the AST generated by `swc` and generate our IR
use serde::{Deserialize, Serialize};

use swc_core::ecma::ast::{
    BinExpr, BinaryOp, BlockStmt, Decl, Expr, ExprStmt, FnDecl, Ident, IfStmt, Lit, Param,
    ParenExpr, ReturnStmt, Script, TsKeywordType, TsKeywordTypeKind, TsType, TsTypeAnn, VarDecl,
    VarDeclKind,
};
use swc_core::ecma::ast::{BindingIdent, Pat, Program, Stmt};

use crate::ir::{
    IRBinOp, IRBinaryExpr, IRBlockStmt, IRExpr, IRExprStmt, IRFunDef, IRIdent, IRIfStmt, IRLiteral,
    IRNameTy, IRReturnStmt, IRScript, IRVarDef, IR,
};
use crate::ir_type::{IRFunTy, IRTy};
use crate::program::Error;

#[derive(Default)]
pub struct JsToIR;

#[derive(Debug, Serialize, Deserialize)]
pub enum IRError {
    ModulesNotSupported,
    StatementNotSupported,
    ExpressionNotSupported(String),
    BinaryOpNotSupported,
    LiteralNotSupported,
    ParameterNotSupported,
    DeclarationNotSupported,
    VarDeclLenNotSupported,
    VarNotSupported,
    VarDeclNoInitializerNotSupported,
    TsTypeNotSupported,
    TypeNotSupported(String),
    PatNotSupported,
    ReturnTypeUnsupported(Box<IRError>),
}

pub type IRResult<A> = Result<A, IRError>;

impl From<IRError> for Error {
    fn from(e: IRError) -> Self {
        Error::IR(e)
    }
}

impl JsToIR {
    pub fn visit_program(&self, program: &Program) -> IRResult<IR> {
        match program {
            Program::Module(module) => Err(IRError::ModulesNotSupported),
            Program::Script(script) => self.visit_script(script),
        }
    }

    pub fn visit_script(&self, script: &Script) -> IRResult<IR> {
        let stmts = &script.body;

        let mut body = Vec::with_capacity(stmts.len());
        for stmt in stmts {
            let ir = self.visit_stmt(stmt)?;
            body.push(ir)
        }

        Ok(IR::Script(IRScript { body }))
    }

    pub fn visit_stmt(&self, stmt: &Stmt) -> IRResult<IR> {
        let unsupported = || -> IRResult<IR> { Err(IRError::ModulesNotSupported) };

        match stmt {
            Stmt::Block(blockkstmt) => self.visit_blockstmt(blockkstmt).map(IR::BlockStmt),
            Stmt::Decl(decl) => self.visit_decl(decl),
            Stmt::Expr(expr) => self.visit_exprstmt(expr).map(IR::ExprStmt),
            Stmt::If(ifstmt) => self.visit_ifstmt(ifstmt).map(IR::IfStmt),
            Stmt::Return(returnstm) => self.visit_returnstm(returnstm).map(IR::ReturnStmt),
            _ => Err(IRError::StatementNotSupported),
        }
    }

    pub fn visit_exprstmt(&self, expr: &ExprStmt) -> IRResult<IRExprStmt> {
        let expr = self.visit_expr(expr.expr.as_ref());
        expr.map(|expr| IRExprStmt { expr })
    }

    pub fn visit_returnstm(&self, ret: &ReturnStmt) -> IRResult<IRReturnStmt> {
        match &ret.arg {
            None => Ok(IRReturnStmt { expr: None }),
            Some(expr) => {
                let res_expr = self.visit_expr(expr.as_ref());

                res_expr.map(|expr| IRReturnStmt { expr: Some(expr) })
            }
        }
    }

    pub fn visit_expr(&self, expr: &Expr) -> IRResult<IRExpr> {
        // let debug = format!("{:?}", expr);

        match expr {
            Expr::Bin(expr) => self.visit_binexpr(expr).map(Box::new).map(IRExpr::Binary),
            Expr::Ident(expr) => self.visit_ident(expr).map(IRExpr::Identifier),
            Expr::Lit(expr) => self.visit_lit(expr).map(IRExpr::Literal),
            Expr::Paren(expr) => self.visit_paren_expr(expr),
            _ => Err(IRError::ExpressionNotSupported(format!("{:?}", expr))),
        }
    }

    pub fn visit_binexpr(&self, expr: &BinExpr) -> IRResult<IRBinaryExpr> {
        let op = self.visit_binaryop(&expr.op)?;
        let left_expr = expr.left.as_ref();
        let right_expr = expr.right.as_ref();

        let left = self.visit_expr(left_expr)?;
        let right = self.visit_expr(right_expr)?;
        let binary = IRBinaryExpr {
            op,
            left: Box::new(left),
            right: Box::new(right),
        };

        Ok(binary)
    }

    pub fn visit_binaryop(&self, op: &BinaryOp) -> IRResult<IRBinOp> {
        match op {
            BinaryOp::Add => Ok(IRBinOp::Add),
            BinaryOp::Div => Ok(IRBinOp::Div),
            BinaryOp::EqEq => Ok(IRBinOp::EqEq),
            BinaryOp::Gt => Ok(IRBinOp::Gt),
            BinaryOp::GtEq => Ok(IRBinOp::GtEq),
            BinaryOp::LogicalAnd => Ok(IRBinOp::LogicalAnd),
            BinaryOp::LogicalOr => Ok(IRBinOp::LogicalOr),
            BinaryOp::Lt => Ok(IRBinOp::Lt),
            BinaryOp::LtEq => Ok(IRBinOp::LtEq),
            BinaryOp::Mod => Ok(IRBinOp::Mod),
            BinaryOp::Mul => Ok(IRBinOp::Mul),
            BinaryOp::NotEq => Ok(IRBinOp::NotEq),
            BinaryOp::Sub => Ok(IRBinOp::Sub),
            _ => Err(IRError::BinaryOpNotSupported),
        }
    }

    pub fn visit_lit(&self, expr: &Lit) -> IRResult<IRLiteral> {
        match expr {
            Lit::Bool(lit) => Ok(IRLiteral::Boolean(lit.value)),
            Lit::Num(lit) => Ok(IRLiteral::Float64(lit.value)),
            Lit::Str(lit) => Ok(IRLiteral::String(lit.value.to_string())),
            _ => Err(IRError::LiteralNotSupported),
        }
    }

    pub fn visit_ident(&self, ident: &Ident) -> IRResult<IRIdent> {
        // Identifiers are always supported
        Ok(IRIdent {
            ident: ident.sym.to_string(),
        })
    }

    pub fn visit_decl(&self, decl: &Decl) -> IRResult<IR> {
        match decl {
            Decl::Fn(fndecl) => self.visit_fndecl(fndecl).map(IR::FunDef),
            Decl::Var(vardecl) => self.visit_vardecl(vardecl.as_ref()).map(IR::VarDef),
            _ => Err(IRError::DeclarationNotSupported),
        }
    }

    pub fn visit_fndecl(&self, fndecl: &FnDecl) -> IRResult<IRFunDef> {
        let name = fndecl.ident.sym.to_string();
        let ident = IRIdent { ident: name };
        let name = Box::new(ident);

        let function = fndecl.function.as_ref();
        let fparams = &function.params;

        // params
        let plen = fparams.len();
        let mut params = Vec::with_capacity(plen);

        for fparam in fparams {
            let irparam = self.visit_param(fparam)?;
            params.push(irparam);
        }

        let ret_ty = match &function.return_type {
            None => Ok(IRTy::UnknownTy),
            Some(ts_type_ann) => self.visit_ts_type_ann(ts_type_ann.as_ref()),
        };

        if let Err(e) = ret_ty {
            return Err(IRError::ReturnTypeUnsupported(Box::new(e)));
        }
        // now it is safe to unwrap
        let ret_ty = Box::new(ret_ty.unwrap());

        // ready to compute the function type
        let param_tys = params.iter().map(|p| p.ty.clone()).collect();
        let fun_ty = IRFunTy { param_tys, ret_ty };

        // body
        let ref_body = function.body.as_ref();
        let body = ref_body
            .map(|blockstmt| self.visit_blockstmt(blockstmt))
            .unwrap_or_else(|| Ok(IRBlockStmt::default()))?;

        Ok(IRFunDef {
            name,
            params,
            fun_ty,
            body: Box::new(body),
        })
    }

    pub fn visit_param(&self, param: &Param) -> IRResult<IRNameTy> {
        let pat = &param.pat;
        // We only support one style of function parameter declarations
        self.visit_pat_as_binding_ident(pat)
    }

    /// Visit a [Pat] trying to match a [BindingIdent] and nothing else.
    /// Extract the respective name and type.
    /// TODO more precise type extraction, currently we just return [IRTy::AnyTy].
    pub fn visit_pat_as_binding_ident(&self, pat: &Pat) -> IRResult<IRNameTy> {
        match pat {
            Pat::Ident(BindingIdent { id, type_ann }) => {
                let name = id.sym.to_string();
                let ident = IRIdent { ident: name };
                let name = Box::new(ident);

                match type_ann {
                    None => {
                        let ty = IRTy::UnknownTy;

                        Ok(IRNameTy { name, ty })
                    }
                    Some(ts_type_ann) => {
                        let ts_type = &*ts_type_ann.type_ann;
                        let ty = self.visit_ts_type(ts_type)?;

                        Ok(IRNameTy { name, ty })
                    }
                }
            }
            _ => Err(IRError::PatNotSupported),
        }
    }

    fn visit_vardecl(&self, vardecl: &VarDecl) -> IRResult<IRVarDef> {
        if vardecl.decls.len() != 1 {
            Err(IRError::VarDeclLenNotSupported)
        } else {
            match vardecl.kind {
                VarDeclKind::Var => Err(IRError::VarNotSupported),

                VarDeclKind::Let | VarDeclKind::Const => {
                    let is_mutable = vardecl.kind == VarDeclKind::Let;
                    let decl = &vardecl.decls[0];

                    // get name and type
                    // Note that there should always be an identifier here, hence the unwrap()
                    let namety = self.visit_pat_as_binding_ident(&decl.name)?;

                    // get the assignment expression
                    // Note that we require an expression to exist, otherwise it's a syntax error
                    match &decl.init {
                        None => Err(IRError::VarDeclNoInitializerNotSupported),

                        Some(expr_box) => {
                            let expr = expr_box.as_ref();
                            let value = self.visit_expr(expr)?;

                            let name = namety.name;
                            let ty = namety.ty;

                            Ok(IRVarDef {
                                name,
                                ty,
                                is_mutable,
                                value: Box::new(value),
                            })
                        }
                    }
                }
            }
        }
    }

    fn visit_ifstmt(&self, ifstmt: &IfStmt) -> IRResult<IRIfStmt> {
        // compute IF
        let __if: IRExpr = self.visit_expr(&ifstmt.test)?;
        // compute THEN
        let __then: IR = self.visit_stmt(ifstmt.cons.as_ref())?;
        // compute ELSE
        let __else = ifstmt
            .alt
            .as_ref()
            .map(|stmt| self.visit_stmt(stmt.as_ref()))
            .unwrap_or_else(|| Ok(IR::BlockStmt(IRBlockStmt::default())))?;

        let _if = Box::new(__if);
        let _then = Box::new(__then);
        let _else = Box::new(__else);

        Ok(IRIfStmt { _if, _then, _else })
    }

    fn visit_blockstmt(&self, blockstmt: &BlockStmt) -> IRResult<IRBlockStmt> {
        let stmts = &blockstmt.stmts;

        let blen = stmts.len();
        let mut nodes = Vec::with_capacity(blen);

        for stmt in stmts {
            let ir = self.visit_stmt(stmt)?;
            nodes.push(ir);
        }

        Ok(IRBlockStmt { body: nodes })
    }

    fn visit_ts_type_ann(&self, ts_type_ann: &TsTypeAnn) -> IRResult<IRTy> {
        self.visit_ts_type(&ts_type_ann.type_ann)
    }

    fn visit_ts_type(&self, ts_type: &TsType) -> IRResult<IRTy> {
        match ts_type {
            TsType::TsKeywordType(kwd_type) => self.visit_ts_keyword_type(kwd_type),
            _ => Err(IRError::TsTypeNotSupported),
        }
    }

    fn visit_ts_keyword_type(&self, kwd_type: &TsKeywordType) -> IRResult<IRTy> {
        let kind = kwd_type.kind;
        match kind {
            TsKeywordTypeKind::TsNumberKeyword => Ok(IRTy::Float64Ty),
            TsKeywordTypeKind::TsBooleanKeyword => Ok(IRTy::BooleanTy),
            TsKeywordTypeKind::TsBigIntKeyword => Ok(IRTy::BigIntTy),
            TsKeywordTypeKind::TsStringKeyword => Ok(IRTy::StringTy),
            TsKeywordTypeKind::TsVoidKeyword => Ok(IRTy::UnitTy),
            _ => Err(IRError::TypeNotSupported(format!("{:?}", kind))),
        }
    }

    fn visit_paren_expr(&self, expr: &ParenExpr) -> IRResult<IRExpr> {
        self.visit_expr(expr.expr.as_ref())
    }
}
